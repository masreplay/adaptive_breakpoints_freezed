// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'adaptive_window_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AdaptiveWindowType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() xs,
    required TResult Function() s,
    required TResult Function() m,
    required TResult Function() l,
    required TResult Function() xl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? xs,
    TResult? Function()? s,
    TResult? Function()? m,
    TResult? Function()? l,
    TResult? Function()? xl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? xs,
    TResult Function()? s,
    TResult Function()? m,
    TResult Function()? l,
    TResult Function()? xl,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AdaptiveWindowTypeXs value) xs,
    required TResult Function(_AdaptiveWindowTypeS value) s,
    required TResult Function(_AdaptiveWindowTypeM value) m,
    required TResult Function(_AdaptiveWindowTypeL value) l,
    required TResult Function(_AdaptiveWindowTypeXl value) xl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AdaptiveWindowTypeXs value)? xs,
    TResult? Function(_AdaptiveWindowTypeS value)? s,
    TResult? Function(_AdaptiveWindowTypeM value)? m,
    TResult? Function(_AdaptiveWindowTypeL value)? l,
    TResult? Function(_AdaptiveWindowTypeXl value)? xl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AdaptiveWindowTypeXs value)? xs,
    TResult Function(_AdaptiveWindowTypeS value)? s,
    TResult Function(_AdaptiveWindowTypeM value)? m,
    TResult Function(_AdaptiveWindowTypeL value)? l,
    TResult Function(_AdaptiveWindowTypeXl value)? xl,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdaptiveWindowTypeCopyWith<$Res> {
  factory $AdaptiveWindowTypeCopyWith(
          AdaptiveWindowType value, $Res Function(AdaptiveWindowType) then) =
      _$AdaptiveWindowTypeCopyWithImpl<$Res, AdaptiveWindowType>;
}

/// @nodoc
class _$AdaptiveWindowTypeCopyWithImpl<$Res, $Val extends AdaptiveWindowType>
    implements $AdaptiveWindowTypeCopyWith<$Res> {
  _$AdaptiveWindowTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_AdaptiveWindowTypeXsCopyWith<$Res> {
  factory _$$_AdaptiveWindowTypeXsCopyWith(_$_AdaptiveWindowTypeXs value,
          $Res Function(_$_AdaptiveWindowTypeXs) then) =
      __$$_AdaptiveWindowTypeXsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AdaptiveWindowTypeXsCopyWithImpl<$Res>
    extends _$AdaptiveWindowTypeCopyWithImpl<$Res, _$_AdaptiveWindowTypeXs>
    implements _$$_AdaptiveWindowTypeXsCopyWith<$Res> {
  __$$_AdaptiveWindowTypeXsCopyWithImpl(_$_AdaptiveWindowTypeXs _value,
      $Res Function(_$_AdaptiveWindowTypeXs) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AdaptiveWindowTypeXs extends _AdaptiveWindowTypeXs {
  const _$_AdaptiveWindowTypeXs() : super._();

  @override
  String toString() {
    return 'AdaptiveWindowType.xs()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AdaptiveWindowTypeXs);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() xs,
    required TResult Function() s,
    required TResult Function() m,
    required TResult Function() l,
    required TResult Function() xl,
  }) {
    return xs();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? xs,
    TResult? Function()? s,
    TResult? Function()? m,
    TResult? Function()? l,
    TResult? Function()? xl,
  }) {
    return xs?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? xs,
    TResult Function()? s,
    TResult Function()? m,
    TResult Function()? l,
    TResult Function()? xl,
    required TResult orElse(),
  }) {
    if (xs != null) {
      return xs();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AdaptiveWindowTypeXs value) xs,
    required TResult Function(_AdaptiveWindowTypeS value) s,
    required TResult Function(_AdaptiveWindowTypeM value) m,
    required TResult Function(_AdaptiveWindowTypeL value) l,
    required TResult Function(_AdaptiveWindowTypeXl value) xl,
  }) {
    return xs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AdaptiveWindowTypeXs value)? xs,
    TResult? Function(_AdaptiveWindowTypeS value)? s,
    TResult? Function(_AdaptiveWindowTypeM value)? m,
    TResult? Function(_AdaptiveWindowTypeL value)? l,
    TResult? Function(_AdaptiveWindowTypeXl value)? xl,
  }) {
    return xs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AdaptiveWindowTypeXs value)? xs,
    TResult Function(_AdaptiveWindowTypeS value)? s,
    TResult Function(_AdaptiveWindowTypeM value)? m,
    TResult Function(_AdaptiveWindowTypeL value)? l,
    TResult Function(_AdaptiveWindowTypeXl value)? xl,
    required TResult orElse(),
  }) {
    if (xs != null) {
      return xs(this);
    }
    return orElse();
  }
}

abstract class _AdaptiveWindowTypeXs extends AdaptiveWindowType {
  const factory _AdaptiveWindowTypeXs() = _$_AdaptiveWindowTypeXs;
  const _AdaptiveWindowTypeXs._() : super._();
}

/// @nodoc
abstract class _$$_AdaptiveWindowTypeSCopyWith<$Res> {
  factory _$$_AdaptiveWindowTypeSCopyWith(_$_AdaptiveWindowTypeS value,
          $Res Function(_$_AdaptiveWindowTypeS) then) =
      __$$_AdaptiveWindowTypeSCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AdaptiveWindowTypeSCopyWithImpl<$Res>
    extends _$AdaptiveWindowTypeCopyWithImpl<$Res, _$_AdaptiveWindowTypeS>
    implements _$$_AdaptiveWindowTypeSCopyWith<$Res> {
  __$$_AdaptiveWindowTypeSCopyWithImpl(_$_AdaptiveWindowTypeS _value,
      $Res Function(_$_AdaptiveWindowTypeS) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AdaptiveWindowTypeS extends _AdaptiveWindowTypeS {
  const _$_AdaptiveWindowTypeS() : super._();

  @override
  String toString() {
    return 'AdaptiveWindowType.s()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AdaptiveWindowTypeS);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() xs,
    required TResult Function() s,
    required TResult Function() m,
    required TResult Function() l,
    required TResult Function() xl,
  }) {
    return s();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? xs,
    TResult? Function()? s,
    TResult? Function()? m,
    TResult? Function()? l,
    TResult? Function()? xl,
  }) {
    return s?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? xs,
    TResult Function()? s,
    TResult Function()? m,
    TResult Function()? l,
    TResult Function()? xl,
    required TResult orElse(),
  }) {
    if (s != null) {
      return s();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AdaptiveWindowTypeXs value) xs,
    required TResult Function(_AdaptiveWindowTypeS value) s,
    required TResult Function(_AdaptiveWindowTypeM value) m,
    required TResult Function(_AdaptiveWindowTypeL value) l,
    required TResult Function(_AdaptiveWindowTypeXl value) xl,
  }) {
    return s(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AdaptiveWindowTypeXs value)? xs,
    TResult? Function(_AdaptiveWindowTypeS value)? s,
    TResult? Function(_AdaptiveWindowTypeM value)? m,
    TResult? Function(_AdaptiveWindowTypeL value)? l,
    TResult? Function(_AdaptiveWindowTypeXl value)? xl,
  }) {
    return s?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AdaptiveWindowTypeXs value)? xs,
    TResult Function(_AdaptiveWindowTypeS value)? s,
    TResult Function(_AdaptiveWindowTypeM value)? m,
    TResult Function(_AdaptiveWindowTypeL value)? l,
    TResult Function(_AdaptiveWindowTypeXl value)? xl,
    required TResult orElse(),
  }) {
    if (s != null) {
      return s(this);
    }
    return orElse();
  }
}

abstract class _AdaptiveWindowTypeS extends AdaptiveWindowType {
  const factory _AdaptiveWindowTypeS() = _$_AdaptiveWindowTypeS;
  const _AdaptiveWindowTypeS._() : super._();
}

/// @nodoc
abstract class _$$_AdaptiveWindowTypeMCopyWith<$Res> {
  factory _$$_AdaptiveWindowTypeMCopyWith(_$_AdaptiveWindowTypeM value,
          $Res Function(_$_AdaptiveWindowTypeM) then) =
      __$$_AdaptiveWindowTypeMCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AdaptiveWindowTypeMCopyWithImpl<$Res>
    extends _$AdaptiveWindowTypeCopyWithImpl<$Res, _$_AdaptiveWindowTypeM>
    implements _$$_AdaptiveWindowTypeMCopyWith<$Res> {
  __$$_AdaptiveWindowTypeMCopyWithImpl(_$_AdaptiveWindowTypeM _value,
      $Res Function(_$_AdaptiveWindowTypeM) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AdaptiveWindowTypeM extends _AdaptiveWindowTypeM {
  const _$_AdaptiveWindowTypeM() : super._();

  @override
  String toString() {
    return 'AdaptiveWindowType.m()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AdaptiveWindowTypeM);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() xs,
    required TResult Function() s,
    required TResult Function() m,
    required TResult Function() l,
    required TResult Function() xl,
  }) {
    return m();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? xs,
    TResult? Function()? s,
    TResult? Function()? m,
    TResult? Function()? l,
    TResult? Function()? xl,
  }) {
    return m?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? xs,
    TResult Function()? s,
    TResult Function()? m,
    TResult Function()? l,
    TResult Function()? xl,
    required TResult orElse(),
  }) {
    if (m != null) {
      return m();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AdaptiveWindowTypeXs value) xs,
    required TResult Function(_AdaptiveWindowTypeS value) s,
    required TResult Function(_AdaptiveWindowTypeM value) m,
    required TResult Function(_AdaptiveWindowTypeL value) l,
    required TResult Function(_AdaptiveWindowTypeXl value) xl,
  }) {
    return m(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AdaptiveWindowTypeXs value)? xs,
    TResult? Function(_AdaptiveWindowTypeS value)? s,
    TResult? Function(_AdaptiveWindowTypeM value)? m,
    TResult? Function(_AdaptiveWindowTypeL value)? l,
    TResult? Function(_AdaptiveWindowTypeXl value)? xl,
  }) {
    return m?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AdaptiveWindowTypeXs value)? xs,
    TResult Function(_AdaptiveWindowTypeS value)? s,
    TResult Function(_AdaptiveWindowTypeM value)? m,
    TResult Function(_AdaptiveWindowTypeL value)? l,
    TResult Function(_AdaptiveWindowTypeXl value)? xl,
    required TResult orElse(),
  }) {
    if (m != null) {
      return m(this);
    }
    return orElse();
  }
}

abstract class _AdaptiveWindowTypeM extends AdaptiveWindowType {
  const factory _AdaptiveWindowTypeM() = _$_AdaptiveWindowTypeM;
  const _AdaptiveWindowTypeM._() : super._();
}

/// @nodoc
abstract class _$$_AdaptiveWindowTypeLCopyWith<$Res> {
  factory _$$_AdaptiveWindowTypeLCopyWith(_$_AdaptiveWindowTypeL value,
          $Res Function(_$_AdaptiveWindowTypeL) then) =
      __$$_AdaptiveWindowTypeLCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AdaptiveWindowTypeLCopyWithImpl<$Res>
    extends _$AdaptiveWindowTypeCopyWithImpl<$Res, _$_AdaptiveWindowTypeL>
    implements _$$_AdaptiveWindowTypeLCopyWith<$Res> {
  __$$_AdaptiveWindowTypeLCopyWithImpl(_$_AdaptiveWindowTypeL _value,
      $Res Function(_$_AdaptiveWindowTypeL) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AdaptiveWindowTypeL extends _AdaptiveWindowTypeL {
  const _$_AdaptiveWindowTypeL() : super._();

  @override
  String toString() {
    return 'AdaptiveWindowType.l()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AdaptiveWindowTypeL);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() xs,
    required TResult Function() s,
    required TResult Function() m,
    required TResult Function() l,
    required TResult Function() xl,
  }) {
    return l();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? xs,
    TResult? Function()? s,
    TResult? Function()? m,
    TResult? Function()? l,
    TResult? Function()? xl,
  }) {
    return l?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? xs,
    TResult Function()? s,
    TResult Function()? m,
    TResult Function()? l,
    TResult Function()? xl,
    required TResult orElse(),
  }) {
    if (l != null) {
      return l();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AdaptiveWindowTypeXs value) xs,
    required TResult Function(_AdaptiveWindowTypeS value) s,
    required TResult Function(_AdaptiveWindowTypeM value) m,
    required TResult Function(_AdaptiveWindowTypeL value) l,
    required TResult Function(_AdaptiveWindowTypeXl value) xl,
  }) {
    return l(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AdaptiveWindowTypeXs value)? xs,
    TResult? Function(_AdaptiveWindowTypeS value)? s,
    TResult? Function(_AdaptiveWindowTypeM value)? m,
    TResult? Function(_AdaptiveWindowTypeL value)? l,
    TResult? Function(_AdaptiveWindowTypeXl value)? xl,
  }) {
    return l?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AdaptiveWindowTypeXs value)? xs,
    TResult Function(_AdaptiveWindowTypeS value)? s,
    TResult Function(_AdaptiveWindowTypeM value)? m,
    TResult Function(_AdaptiveWindowTypeL value)? l,
    TResult Function(_AdaptiveWindowTypeXl value)? xl,
    required TResult orElse(),
  }) {
    if (l != null) {
      return l(this);
    }
    return orElse();
  }
}

abstract class _AdaptiveWindowTypeL extends AdaptiveWindowType {
  const factory _AdaptiveWindowTypeL() = _$_AdaptiveWindowTypeL;
  const _AdaptiveWindowTypeL._() : super._();
}

/// @nodoc
abstract class _$$_AdaptiveWindowTypeXlCopyWith<$Res> {
  factory _$$_AdaptiveWindowTypeXlCopyWith(_$_AdaptiveWindowTypeXl value,
          $Res Function(_$_AdaptiveWindowTypeXl) then) =
      __$$_AdaptiveWindowTypeXlCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AdaptiveWindowTypeXlCopyWithImpl<$Res>
    extends _$AdaptiveWindowTypeCopyWithImpl<$Res, _$_AdaptiveWindowTypeXl>
    implements _$$_AdaptiveWindowTypeXlCopyWith<$Res> {
  __$$_AdaptiveWindowTypeXlCopyWithImpl(_$_AdaptiveWindowTypeXl _value,
      $Res Function(_$_AdaptiveWindowTypeXl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AdaptiveWindowTypeXl extends _AdaptiveWindowTypeXl {
  const _$_AdaptiveWindowTypeXl() : super._();

  @override
  String toString() {
    return 'AdaptiveWindowType.xl()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AdaptiveWindowTypeXl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() xs,
    required TResult Function() s,
    required TResult Function() m,
    required TResult Function() l,
    required TResult Function() xl,
  }) {
    return xl();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? xs,
    TResult? Function()? s,
    TResult? Function()? m,
    TResult? Function()? l,
    TResult? Function()? xl,
  }) {
    return xl?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? xs,
    TResult Function()? s,
    TResult Function()? m,
    TResult Function()? l,
    TResult Function()? xl,
    required TResult orElse(),
  }) {
    if (xl != null) {
      return xl();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AdaptiveWindowTypeXs value) xs,
    required TResult Function(_AdaptiveWindowTypeS value) s,
    required TResult Function(_AdaptiveWindowTypeM value) m,
    required TResult Function(_AdaptiveWindowTypeL value) l,
    required TResult Function(_AdaptiveWindowTypeXl value) xl,
  }) {
    return xl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AdaptiveWindowTypeXs value)? xs,
    TResult? Function(_AdaptiveWindowTypeS value)? s,
    TResult? Function(_AdaptiveWindowTypeM value)? m,
    TResult? Function(_AdaptiveWindowTypeL value)? l,
    TResult? Function(_AdaptiveWindowTypeXl value)? xl,
  }) {
    return xl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AdaptiveWindowTypeXs value)? xs,
    TResult Function(_AdaptiveWindowTypeS value)? s,
    TResult Function(_AdaptiveWindowTypeM value)? m,
    TResult Function(_AdaptiveWindowTypeL value)? l,
    TResult Function(_AdaptiveWindowTypeXl value)? xl,
    required TResult orElse(),
  }) {
    if (xl != null) {
      return xl(this);
    }
    return orElse();
  }
}

abstract class _AdaptiveWindowTypeXl extends AdaptiveWindowType {
  const factory _AdaptiveWindowTypeXl() = _$_AdaptiveWindowTypeXl;
  const _AdaptiveWindowTypeXl._() : super._();
}
